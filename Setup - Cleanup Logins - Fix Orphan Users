USE tempdb;
GO

SET ANSI_NULLS ON;
SET QUOTED_IDENTIFIER ON;
GO

CREATE OR ALTER PROCEDURE dbo.usp_CleanupInvalidUsers
    @TargetAdminLogin SYSNAME = NULL,
    @Execute          BIT = 0,    
    @Print            BIT = 1     
AS
/**
-- ==========================================================================================
-- Procedure:   usp_CleanupInvalidUsers
-- 
-- Description: 
--   1. Identifies Windows Logins that no longer exist in AD/Local OS.
--   2. Transfers ownership of Endpoints, Databases, and Agent Jobs to a designated admin.
--   3. Transfers ownership of schemas owned by invalid users within databases.
--   4. Drops the orphaned database users and the server login.
-- ==========================================================================================
**/
BEGIN
    SET NOCOUNT ON;

    -- --- 1. INITIALIZATION & LOGGING TABLE ---
    -- All columns made NULLable to prevent "Cannot insert NULL" errors during failures
    DECLARE @ActionLog TABLE (
        ID INT IDENTITY(1,1),
        Step         NVARCHAR(50)  NULL,
        ActionType   NVARCHAR(50)  NULL,
        ObjectName   SYSNAME       NULL,
        Context      NVARCHAR(255) NULL,
        Status       NVARCHAR(50)  NULL,
        Command      NVARCHAR(MAX) NULL,
        ErrorMessage NVARCHAR(MAX) NULL
    );

    DECLARE @CurrentSQL     NVARCHAR(MAX);
    DECLARE @AdminLoginName SYSNAME;
    DECLARE @ObjectName     SYSNAME;
    DECLARE @CurrentDB      SYSNAME;
    DECLARE @ErrorSeverity  INT;
    DECLARE @ErrorState     INT;

    BEGIN TRY
        -- --- 2. PARAMETER VALIDATION ---
        IF @TargetAdminLogin IS NULL
        BEGIN
            -- Default to SA
            SELECT TOP 1 @AdminLoginName = name FROM sys.server_principals WHERE sid = 0x01;
        END
        ELSE
        BEGIN
            -- Validate specified login is a sysadmin
            IF NOT EXISTS (SELECT 1 FROM sys.server_principals WHERE name = @TargetAdminLogin AND IS_SRVROLEMEMBER('sysadmin', name) = 1)
            BEGIN
                INSERT INTO @ActionLog (Step, Status, ErrorMessage) 
                VALUES ('Validation', 'FAILED', 'The @TargetAdminLogin "' + ISNULL(@TargetAdminLogin,'NULL') + '" is not a valid sysadmin.');
                GOTO FinalReport;
            END
            SET @AdminLoginName = @TargetAdminLogin;
        END

        -- --- 3. IDENTIFY INVALID LOGINS ---
        IF OBJECT_ID('tempdb..#InvalidLogins') IS NOT NULL DROP TABLE #InvalidLogins;
        CREATE TABLE #InvalidLogins ( [SID] VARBINARY(85), [name] SYSNAME );
        
        INSERT INTO #InvalidLogins EXEC sp_validatelogins;
        
        -- Prevent the script from trying to drop the admin currently fixing the server
        DELETE FROM #InvalidLogins WHERE [name] = @AdminLoginName;

        IF NOT EXISTS (SELECT 1 FROM #InvalidLogins)
        BEGIN
            INSERT INTO @ActionLog (Step, Status) VALUES ('Identification', 'No orphaned logins found.');
            GOTO FinalReport;
        END

        -- --- 4. COMMAND GENERATION PHASE ---
        DECLARE LoginCursor CURSOR LOCAL FAST_FORWARD FOR SELECT [name] FROM #InvalidLogins;
        OPEN LoginCursor;
        FETCH NEXT FROM LoginCursor INTO @ObjectName;

        WHILE @@FETCH_STATUS = 0
        BEGIN
            -- 4a. Server Level: Endpoints
            INSERT INTO @ActionLog (Step, ActionType, ObjectName, Status, Command)
            SELECT 'Server', 'ENDPOINT_OWNERSHIP', name, 'QUEUED', 
                   'ALTER AUTHORIZATION ON ENDPOINT::' + QUOTENAME(name) + ' TO ' + QUOTENAME(@AdminLoginName)
            FROM sys.endpoints WHERE principal_id = SUSER_ID(@ObjectName);

            -- 4b. Server Level: Database Ownership
            INSERT INTO @ActionLog (Step, ActionType, ObjectName, Status, Command)
            SELECT 'Server', 'DATABASE_OWNERSHIP', name, 'QUEUED', 
                   'ALTER AUTHORIZATION ON DATABASE::' + QUOTENAME(name) + ' TO ' + QUOTENAME(@AdminLoginName)
            FROM sys.databases WHERE owner_sid = SUSER_SID(@ObjectName);

            -- 4c. Server Level: SQL Agent Jobs
            INSERT INTO @ActionLog (Step, ActionType, ObjectName, Status, Command)
            SELECT 'Agent', 'JOB_OWNERSHIP', name, 'QUEUED', 
                   'EXEC msdb.dbo.sp_update_job @job_name=N''' + REPLACE(name, '''', '''''') + ''', @owner_login_name=N''' + @AdminLoginName + ''''
            FROM msdb.dbo.sysjobs WHERE owner_sid = SUSER_SID(@ObjectName);

            -- 4d. Database Level: Users & Schemas
            DECLARE DBCursor CURSOR LOCAL FAST_FORWARD FOR 
                SELECT name FROM sys.databases 
                WHERE state = 0 AND is_read_only = 0 AND name NOT IN ('tempdb');
            
            OPEN DBCursor;
            FETCH NEXT FROM DBCursor INTO @CurrentDB;
            WHILE @@FETCH_STATUS = 0
            BEGIN
                -- Dynamic SQL to probe each DB for the user and their schemas
                DECLARE @InternalSQL NVARCHAR(MAX) = '
                    SELECT ''Database'', ''SCHEMA_OWNERSHIP'', name, ''' + @CurrentDB + ''', ''QUEUED'', 
                           ''ALTER AUTHORIZATION ON SCHEMA::['' + name + ''] TO ' + QUOTENAME(@AdminLoginName) + '''
                    FROM ' + QUOTENAME(@CurrentDB) + '.sys.schemas WHERE principal_id = USER_ID(''' + @ObjectName + ''');
                    
                    SELECT ''Database'', ''USER_DROP'', name, ''' + @CurrentDB + ''', ''QUEUED'', 
                           ''USE ' + QUOTENAME(@CurrentDB) + '; DROP USER ['' + name + '']''
                    FROM ' + QUOTENAME(@CurrentDB) + '.sys.database_principals WHERE name = ''' + @ObjectName + ''' AND type IN (''S'',''U'',''G'');
                ';
                INSERT INTO @ActionLog (Step, ActionType, ObjectName, Context, Status, Command)
                EXEC sp_executesql @InternalSQL;
                
                FETCH NEXT FROM DBCursor INTO @CurrentDB;
            END
            CLOSE DBCursor; DEALLOCATE DBCursor;

            -- 4e. Server Level: Drop Login (Must be last)
            INSERT INTO @ActionLog (Step, ActionType, ObjectName, Status, Command)
            VALUES ('Server', 'LOGIN_DROP', @ObjectName, 'QUEUED', 'DROP LOGIN ' + QUOTENAME(@ObjectName));

            FETCH NEXT FROM LoginCursor INTO @ObjectName;
        END
        CLOSE LoginCursor; DEALLOCATE LoginCursor;

        -- --- 5. EXECUTION PHASE ---
        IF EXISTS (SELECT 1 FROM @ActionLog WHERE Status = 'QUEUED')
        BEGIN
            DECLARE ExecCursor CURSOR LOCAL FAST_FORWARD FOR 
                SELECT ID, Command FROM @ActionLog WHERE Command IS NOT NULL ORDER BY ID;
            OPEN ExecCursor;
            DECLARE @LogID INT;
            FETCH NEXT FROM ExecCursor INTO @LogID, @CurrentSQL;

            WHILE @@FETCH_STATUS = 0
            BEGIN
                IF @Print = 1 PRINT '-- Executing Step ' + CAST(@LogID AS VARCHAR) + ': ' + @CurrentSQL;
                
                IF @Execute = 1
                BEGIN
                    BEGIN TRY
                        EXEC sp_executesql @CurrentSQL;
                        UPDATE @ActionLog SET Status = 'SUCCESS' WHERE ID = @LogID;
                    END TRY
                    BEGIN CATCH
                        UPDATE @ActionLog SET Status = 'FAILED', ErrorMessage = ERROR_MESSAGE() WHERE ID = @LogID;
                    END CATCH
                END
                ELSE
                BEGIN
                    UPDATE @ActionLog SET Status = 'DRY_RUN' WHERE ID = @LogID;
                END

                FETCH NEXT FROM ExecCursor INTO @LogID, @CurrentSQL;
            END
            CLOSE ExecCursor; DEALLOCATE ExecCursor;
        END

    END TRY
    BEGIN CATCH
        -- Global Error Cleanup
        IF CURSOR_STATUS('local', 'LoginCursor') >= 0 BEGIN CLOSE LoginCursor; DEALLOCATE LoginCursor; END
        IF CURSOR_STATUS('local', 'DBCursor')    >= 0 BEGIN CLOSE DBCursor;    DEALLOCATE DBCursor;    END
        IF CURSOR_STATUS('local', 'ExecCursor')  >= 0 BEGIN CLOSE ExecCursor;  DEALLOCATE ExecCursor;  END

        INSERT INTO @ActionLog (Step, Status, ErrorMessage) 
        VALUES ('CRITICAL_ERROR', 'ABORTED', 'Line ' + CAST(ERROR_LINE() AS VARCHAR) + ': ' + ERROR_MESSAGE());
        
    END CATCH

    -- --- 6. FINAL DETAILED REPORTING ---
    FinalReport:
    
    -- Summary Result Set
    SELECT 
        Step, 
        ActionType, 
        Status, 
        COUNT(*) AS TotalCount
    FROM @ActionLog
    GROUP BY Step, ActionType, Status
    ORDER BY Step;

    -- Detailed Result Set
    SELECT 
        ActionType, 
        ObjectName, 
        Context AS DatabaseContext, 
        Status, 
        ErrorMessage, 
        Command
    FROM @ActionLog
    ORDER BY ID;

END
GO

-- Example Execution:
EXEC dbo.usp_CleanupInvalidUsers

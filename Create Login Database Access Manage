USE tempdb
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE OR ALTER PROCEDURE dbo.usp_GrantAccess
    @UserName               NVARCHAR(128) = 'testinggggg',
    @Print                  BIT           = 1,
    @Execute                BIT           = 0,
    @Password               NVARCHAR(128) = NULL OUTPUT,
    @IsPasswordHashed       BIT           = 0,
    @SID                    VARBINARY(85) = NULL,
    @DBNames                NVARCHAR(MAX) = '', 
    @ExcludeDBs             NVARCHAR(MAX) = NULL,
    @IncludeSystemDBs       BIT           = 0,
    @Schema                 NVARCHAR(128) = NULL,
    @GrantRead              BIT           = 1,
    @GrantWrite             BIT           = 0,
    @GrantExecute           BIT           = 1,
    @GrantViewDefinition    BIT           = 0,
    @GrantViewServerState   BIT           = 0,
    @CustomRoles            NVARCHAR(MAX) = NULL
AS
/*******************************************************************************
Name:           usp_GrantAccess
Description:    Automates security provisioning for SQL Logins and AD Accounts.
                Ensures logins exist, maps users to databases, and applies 
                roles or schema-level permissions.

Parameters:
    @UserName            - Target Login/User name.
    @Print               - 1: Display T-SQL in the message window.
    @Execute             - 1: Run the generated T-SQL.
    @Password            - OUTPUT: Returns the generated password for SQL Logins.
    @IsPasswordHashed    - 1: If @Password is already a hashed string.
    @SID                 - Specific SID for SQL Logins (useful for AG/Mirroring).
    @DBNames             - Comma-separated list. Empty = All non-system DBs.
    @ExcludeDBs          - Comma-separated list of DBs to ignore.
    @IncludeSystemDBs    - 1: Include master, model, msdb.
    @Schema              - If set, grants permissions on this schema ONLY.
    @GrantRead           - Adds db_datareader (or SELECT on @Schema).
    @GrantWrite          - Adds db_datawriter (or INSERT, UPDATE, DELETE on @Schema).
    @GrantExecute        - Adds EXECUTE permission.
    @GrantViewDefinition - Adds VIEW DEFINITION permission.
    @GrantViewServerState- Adds VIEW SERVER STATE (Server-Level).
    @CustomRoles         - Comma-separated list of DB or Server roles.

Returns:
    A result set table showing the Status (SUCCESS/FAILED) for each database.

Notes:
    - Reports "Database not exists" for any DB name provided that is missing.
    - Skips READ_ONLY databases (AG Secondaries) automatically.
*******************************************************************************/
BEGIN
    SET NOCOUNT ON;
    
    -- Basic Validation
    IF @UserName IS NULL
    BEGIN
        RAISERROR('The parameter @UserName is required.', 16, 1);
        RETURN;
    END

    DECLARE @Results TABLE (DBName SYSNAME, Status NVARCHAR(20), Message NVARCHAR(MAX));
    DECLARE @SQL NVARCHAR(MAX);
    DECLARE @IsSqlLogin BIT = IIF(CHARINDEX('\', @UserName) = 0, 1, 0);

    --------------------------------------------------------------------------------
    -- PHASE 0: SECURE PASSWORD GENERATION
    --------------------------------------------------------------------------------
    IF @IsSqlLogin = 1 AND ISNULL(@Password, '') = ''
    BEGIN
        DECLARE @Upper  VARCHAR(26) = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        DECLARE @Lower  VARCHAR(26) = 'abcdefghijklmnopqrstuvwxyz';
        DECLARE @Num    VARCHAR(10) = '0123456789';
        DECLARE @Sym    VARCHAR(10) = '!@#$%^&*()';
        DECLARE @Pool   VARCHAR(100)= @Upper + @Lower + @Num + @Sym;
        
        ;WITH RandChars AS (
            SELECT SUBSTRING(@Upper, (ABS(CHECKSUM(CRYPT_GEN_RANDOM(4))) % 26) + 1, 1) as c 
            UNION ALL SELECT SUBSTRING(@Lower, (ABS(CHECKSUM(CRYPT_GEN_RANDOM(4))) % 26) + 1, 1)
            UNION ALL SELECT SUBSTRING(@Num, (ABS(CHECKSUM(CRYPT_GEN_RANDOM(4))) % 10) + 1, 1)
            UNION ALL SELECT SUBSTRING(@Sym, (ABS(CHECKSUM(CRYPT_GEN_RANDOM(4))) % 10) + 1, 1)
            UNION ALL
            SELECT TOP 12 SUBSTRING(@Pool, (ABS(CHECKSUM(CRYPT_GEN_RANDOM(4))) % LEN(@Pool)) + 1, 1)
            FROM sys.all_columns
        )
        SELECT @Password = (SELECT c + '' FROM RandChars ORDER BY NEWID() FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)');
    END

    --------------------------------------------------------------------------------
    -- PHASE 1: ROLE NORMALIZATION
    --------------------------------------------------------------------------------
    DECLARE @CleanRoles TABLE (RoleName SYSNAME, IsServerRole BIT);
    INSERT INTO @CleanRoles (RoleName, IsServerRole)
    SELECT 
        LTRIM(RTRIM(value)),
        IIF(EXISTS(SELECT 1 FROM sys.server_principals WHERE name = LTRIM(RTRIM(value)) AND type = 'R'), 1, 0)
    FROM STRING_SPLIT(ISNULL(@CustomRoles, ''), ',')
    WHERE LTRIM(RTRIM(value)) <> '';

    --------------------------------------------------------------------------------
    -- PHASE 2: SERVER LEVEL OPERATIONS
    --------------------------------------------------------------------------------
    BEGIN TRY
        IF @IsSqlLogin = 0
        BEGIN
            DECLARE @ResolvedSID VARBINARY(85) = SUSER_SID(@UserName);
            DECLARE @ExistingName SYSNAME;
            SELECT @ExistingName = [name] FROM sys.server_principals WHERE [sid] = @ResolvedSID;

            IF @ExistingName IS NOT NULL AND @ExistingName <> @UserName
            BEGIN
                SET @SQL = N'ALTER LOGIN ' + QUOTENAME(@ExistingName) + N' WITH NAME = ' + QUOTENAME(@UserName) + N';';
                IF @Print = 1 PRINT '-- INFO: Renaming login: ' + @ExistingName + ' -> ' + @UserName;
                IF @Execute = 1 EXEC sp_executesql @SQL;
            END
        END

        IF NOT EXISTS (SELECT 1 FROM sys.server_principals WHERE name = @UserName)
        BEGIN
            IF @IsSqlLogin = 1
                SET @SQL = N'CREATE LOGIN ' + QUOTENAME(@UserName) + N' WITH PASSWORD = ' +
                    IIF(@IsPasswordHashed = 1, @Password + N' HASHED', N'''' + REPLACE(@Password, '''', '''''') + N'''') + 
                    ISNULL(N', SID = ' + CONVERT(NVARCHAR(100), @SID, 1), N'') + N', CHECK_POLICY = ON;';
            ELSE
                SET @SQL = N'CREATE LOGIN ' + QUOTENAME(@UserName) + N' FROM WINDOWS;';
            
            IF @Print = 1 PRINT @SQL;
            IF @Execute = 1 EXEC sp_executesql @SQL;
        END

        DECLARE @SRole SYSNAME;
        DECLARE curSR CURSOR LOCAL FAST_FORWARD FOR SELECT RoleName FROM @CleanRoles WHERE IsServerRole = 1;
        OPEN curSR; FETCH NEXT FROM curSR INTO @SRole;
        WHILE @@FETCH_STATUS = 0
        BEGIN
            SET @SQL = N'ALTER SERVER ROLE ' + QUOTENAME(@SRole) + N' ADD MEMBER ' + QUOTENAME(@UserName) + N';';
            IF @Print = 1 PRINT @SQL;
            IF @Execute = 1 EXEC sp_executesql @SQL;
            FETCH NEXT FROM curSR INTO @SRole;
        END
        CLOSE curSR; DEALLOCATE curSR;

        IF @GrantViewServerState = 1
        BEGIN
            SET @SQL = N'GRANT VIEW SERVER STATE TO ' + QUOTENAME(@UserName) + N';';
            IF @Print = 1 PRINT @SQL;
            IF @Execute = 1 EXEC sp_executesql @SQL;
        END
        
        INSERT INTO @Results (DBName, Status, Message) VALUES ('SERVER_LEVEL', 'SUCCESS', 'Login Processed');
    END TRY
    BEGIN CATCH
        INSERT INTO @Results (DBName, Status, Message) VALUES ('SERVER_LEVEL', 'FAILED', ERROR_MESSAGE());
    END CATCH

    --------------------------------------------------------------------------------
    -- PHASE 3: DATABASE LEVEL OPERATIONS
    --------------------------------------------------------------------------------
    
    -- 3a. VALIDATION: Catch and report missing databases from the input string
    IF ISNULL(@DBNames, '') <> ''
    BEGIN
        INSERT INTO @Results (DBName, Status, Message)
        SELECT 
            LTRIM(RTRIM(value)) AS DBName, 
            'FAILED' AS Status, 
            'Database not exists' AS Message
        FROM STRING_SPLIT(@DBNames, ',')
        WHERE LTRIM(RTRIM(value)) NOT IN (SELECT name FROM sys.databases)
          AND LTRIM(RTRIM(value)) <> '';
    END

    -- 3b. CURSOR: Only iterates through databases that actually exist
    DECLARE @DBName SYSNAME;
    DECLARE db_cursor CURSOR LOCAL FAST_FORWARD FOR
        SELECT name FROM sys.databases
        WHERE state_desc = 'ONLINE' 
          AND user_access_desc = 'MULTI_USER'
          AND (@DBNames = '' OR name IN (SELECT LTRIM(RTRIM(value)) FROM STRING_SPLIT(@DBNames, ',')))
          AND (@ExcludeDBs IS NULL OR name NOT IN (SELECT LTRIM(RTRIM(value)) FROM STRING_SPLIT(@ExcludeDBs, ',')))
          AND (@IncludeSystemDBs = 1 OR (is_distributor = 0 AND name NOT IN ('master', 'model', 'msdb', 'tempdb')));

    OPEN db_cursor;
    FETCH NEXT FROM db_cursor INTO @DBName;

    WHILE @@FETCH_STATUS = 0
    BEGIN
        BEGIN TRY
            IF DATABASEPROPERTYEX(@DBName, 'Updateability') = 'READ_ONLY'
                THROW 50001, 'Database is READ_ONLY. Skipping.', 1;

            SET @SQL = N'USE ' + QUOTENAME(@DBName) + N';' + CHAR(10) +
                       N'IF NOT EXISTS (SELECT 1 FROM sys.database_principals WHERE name = ' + QUOTENAME(@UserName, '''') + N')' + CHAR(10) +
                       N'    CREATE USER ' + QUOTENAME(@UserName) + N' FOR LOGIN ' + QUOTENAME(@UserName) + N';' + CHAR(10) +
                       N'ELSE ALTER USER ' + QUOTENAME(@UserName) + N' WITH LOGIN = ' + QUOTENAME(@UserName) + N';' + CHAR(10);

            IF @GrantRead = 1
                SET @SQL += IIF(@Schema IS NULL, N'ALTER ROLE db_datareader ADD MEMBER ' + QUOTENAME(@UserName) + N';', 
                            N'GRANT SELECT ON SCHEMA::' + QUOTENAME(@Schema) + N' TO ' + QUOTENAME(@UserName) + N';') + CHAR(10);
            IF @GrantWrite = 1
                SET @SQL += IIF(@Schema IS NULL, N'ALTER ROLE db_datawriter ADD MEMBER ' + QUOTENAME(@UserName) + N';', 
                            N'GRANT INSERT, UPDATE, DELETE ON SCHEMA::' + QUOTENAME(@Schema) + N' TO ' + QUOTENAME(@UserName) + N';') + CHAR(10);
            IF @GrantExecute = 1
                SET @SQL += IIF(@Schema IS NULL, N'GRANT EXECUTE TO ' + QUOTENAME(@UserName) + N';', 
                            N'GRANT EXECUTE ON SCHEMA::' + QUOTENAME(@Schema) + N' TO ' + QUOTENAME(@UserName) + N';') + CHAR(10);
            IF @GrantViewDefinition = 1
                SET @SQL += N'GRANT VIEW DEFINITION TO ' + QUOTENAME(@UserName) + N';' + CHAR(10);

            DECLARE @DBRoleSQL NVARCHAR(MAX) = '';
            SELECT @DBRoleSQL += 
                N'IF EXISTS (SELECT 1 FROM sys.database_principals WHERE name = ' + QUOTENAME(RoleName, '''') + N' AND type = ''R'') ' +
                N'ALTER ROLE ' + QUOTENAME(RoleName) + N' ADD MEMBER ' + QUOTENAME(@UserName) + N';' + CHAR(10)
            FROM @CleanRoles WHERE IsServerRole = 0;

            SET @SQL += @DBRoleSQL;

            IF @Print = 1 PRINT '-- PERMISSIONS FOR: ' + @DBName + CHAR(10) + @SQL;
            IF @Execute = 1 EXEC sp_executesql @SQL;
            
            INSERT INTO @Results (DBName, Status, Message) VALUES (@DBName, 'SUCCESS', 'Permissions Applied');
        END TRY
        BEGIN CATCH
            INSERT INTO @Results (DBName, Status, Message) VALUES (@DBName, 'FAILED', ERROR_MESSAGE());
        END CATCH

        FETCH NEXT FROM db_cursor INTO @DBName;
    END

    CLOSE db_cursor; DEALLOCATE db_cursor;

    -- Final Summary
    IF @Print = 1 AND @IsSqlLogin = 1 PRINT '-- GENERATED PASSWORD: ' + ISNULL(@Password, 'N/A');
    SELECT DBName, Status, Message FROM @Results ORDER BY Status DESC, DBName ASC;
END
GO

EXEC usp_GrantAccess

USE tempdb;
GO

CREATE OR ALTER PROCEDURE dbo.usp_GrantAccess
    -- General & Action Parameters
    @UserName NVARCHAR(128) = 'username',
    @Print BIT = 1,
    @Execute BIT = 0,

    -- Login Creation Parameters
    @Password NVARCHAR(128) = NULL OUTPUT, -- INPUT: Provide a specific password.
                                            -- OUTPUT: Leave NULL or empty to have a strong password generated and returned.
    @IsPasswordHashed BIT = 0,
    @SID VARBINARY(85) = NULL,

    -- Database & Schema Scope
    @DBNames NVARCHAR(MAX) = 'db1, db2, db3', --pass null for all dbs
    @ExcludeDBs NVARCHAR(MAX) = NULL,
    @IncludeSystemDBs BIT = 0,
    @Schema NVARCHAR(128) = NULL,

    -- Permission Flags
    @GrantRead BIT = 1,
    @GrantWrite BIT = 0,
    @GrantExecute BIT = 0,
    @GrantViewDefinition BIT = 0,
    @GrantViewServerState BIT = 0,
    @CustomRoles NVARCHAR(MAX) = 'db_ddladmin'

AS
BEGIN
    SET NOCOUNT ON;

    -- 1. PRE-FLIGHT CHECKS & SETUP
    --------------------------------------------------------------------------------
    IF @Print = 0 AND @Execute = 0
    BEGIN
        PRINT '-- INFO: Both @Print and @Execute are set to 0. No action will be taken.';
        RETURN;
    END

    DECLARE @SQL NVARCHAR(MAX);
    DECLARE @IsSqlLogin BIT = IIF(CHARINDEX('\', @UserName) = 0, 1, 0);

    -- 2. PASSWORD GENERATION & VALIDATION (for SQL Logins)
    --------------------------------------------------------------------------------
    IF @IsSqlLogin = 1 AND ISNULL(@Password, '') = ''
    BEGIN
        -- A password was not supplied, so we generate a strong one.
        SET @Password = (
            SELECT
                SUBSTRING('abcdefghijklmnopqrstuvwxyz', ABS(CHECKSUM(NEWID())) % 26 + 1, 1) +
                SUBSTRING('ABCDEFGHIJKLMNOPQRSTUVWXYZ', ABS(CHECKSUM(NEWID())) % 26 + 1, 1) +
                SUBSTRING('0123456789', ABS(CHECKSUM(NEWID())) % 10 + 1, 1) +
                SUBSTRING('!@#$%^&*()-_=+[]{}', ABS(CHECKSUM(NEWID())) % 19 + 1, 1) +
                (
                    SELECT TOP 14 SUBSTRING('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-_=+[]{}', ABS(CHECKSUM(NEWID())) % 75 + 1, 1)
                    FROM sys.all_objects
                    FOR XML PATH('')
                )
        );
        IF @Print = 1 PRINT '-- INFO: A strong password has been generated for ' + QUOTENAME(@UserName) + '.';
    END

    -- Validate the password (either supplied or generated) if it's not a hashed password
    IF @IsSqlLogin = 1 AND @IsPasswordHashed = 0 AND (
        LEN(ISNULL(@Password, '')) < 16 OR @Password NOT LIKE '%[A-Z]%' OR @Password NOT LIKE '%[a-z]%' OR
        @Password NOT LIKE '%[0-9]%' OR @Password NOT LIKE '%[^a-zA-Z0-9]%'
    )
    BEGIN
        RAISERROR('Password must be at least 16 characters and include an uppercase letter, lowercase letter, number, and special character.', 16, 1);
        RETURN;
    END

    BEGIN TRY
        -- 3. SERVER-LEVEL: CREATE LOGIN and GRANT SERVER PERMISSIONS
        --------------------------------------------------------------------------------
        IF NOT EXISTS (SELECT 1 FROM sys.server_principals WHERE name = @UserName)
        BEGIN
            IF @IsSqlLogin = 1
            BEGIN
                SET @SQL = N'CREATE LOGIN ' + QUOTENAME(@UserName) + N' WITH PASSWORD = ' +
                    IIF(@IsPasswordHashed = 1, @Password, N'''' + REPLACE(@Password, '''', '''''') + N'''') + -- Note: Hashed password doesn't need quotes
                    ISNULL(N', SID = ' + CONVERT(NVARCHAR(100), @SID, 1), N'') +
                    N', DEFAULT_DATABASE = [master], CHECK_POLICY = OFF;';
            END
            ELSE
            BEGIN
                SET @SQL = N'CREATE LOGIN ' + QUOTENAME(@UserName) + N' FROM WINDOWS;';
            END

            IF @Print = 1 PRINT @SQL;
            IF @Execute = 1 EXEC sp_executesql @SQL;
        END

        IF @GrantViewServerState = 1
        BEGIN
            SET @SQL = N'GRANT VIEW SERVER STATE TO ' + QUOTENAME(@UserName) + N';';
            IF @Print = 1 PRINT @SQL;
            IF @Execute = 1 EXEC sp_executesql @SQL;
        END

        -- 4. DATABASE-LEVEL: CREATE USERS and GRANT DATABASE PERMISSIONS
        -- (The rest of the procedure remains the same)
        DECLARE @DBNameCursor NVARCHAR(128);
        DECLARE db_cursor CURSOR FOR
            SELECT name FROM sys.databases
            WHERE state_desc = 'ONLINE'
              AND (@DBNames = '' OR name IN (SELECT LTRIM(RTRIM(value)) FROM STRING_SPLIT(@DBNames, ',')))
              AND (@ExcludeDBs IS NULL OR name NOT IN (SELECT LTRIM(RTRIM(value)) FROM STRING_SPLIT(@ExcludeDBs, ',')))
              AND (@IncludeSystemDBs = 1 OR is_distributor = 0 AND group_database_id IS NULL AND source_database_id IS NULL AND name NOT IN ('master', 'model', 'msdb', 'tempdb'));

        OPEN db_cursor;
        FETCH NEXT FROM db_cursor INTO @DBNameCursor;

        WHILE @@FETCH_STATUS = 0
        BEGIN
            SET @SQL = N'USE ' + QUOTENAME(@DBNameCursor) + N';' + CHAR(13) + CHAR(10) +
                       N'IF NOT EXISTS (SELECT 1 FROM sys.database_principals WHERE name = ' + QUOTENAME(@UserName, '''') + N')' + CHAR(13) + CHAR(10) +
                       N'    CREATE USER ' + QUOTENAME(@UserName) + N' FOR LOGIN ' + QUOTENAME(@UserName) + N';' + CHAR(13) + CHAR(10) +
                       N'ELSE' + CHAR(13) + CHAR(10) +
                       N'    ALTER USER ' + QUOTENAME(@UserName) + N' WITH LOGIN = ' + QUOTENAME(@UserName) + N';';

            IF @GrantRead = 1 SET @SQL += IIF(@Schema IS NULL, CHAR(10) + N' ALTER ROLE db_datareader ADD MEMBER ' + QUOTENAME(@UserName) + N';', N' GRANT SELECT ON SCHEMA::' + QUOTENAME(@Schema) + N' TO ' + QUOTENAME(@UserName) + N';');
            IF @GrantWrite = 1 SET @SQL += IIF(@Schema IS NULL, CHAR(10) + N' ALTER ROLE db_datawriter ADD MEMBER ' + QUOTENAME(@UserName) + N';', N' GRANT INSERT, UPDATE, DELETE ON SCHEMA::' + QUOTENAME(@Schema) + N' TO ' + QUOTENAME(@UserName) + N';');
            IF @GrantExecute = 1 SET @SQL += IIF(@Schema IS NULL, CHAR(10) + N' GRANT EXECUTE TO ' + QUOTENAME(@UserName) + N';', N' GRANT EXECUTE ON SCHEMA::' + QUOTENAME(@Schema) + N' TO ' + QUOTENAME(@UserName) + N';');
            IF @GrantViewDefinition = 1 SET @SQL += IIF(@Schema IS NULL, CHAR(10) + N' GRANT VIEW DEFINITION TO ' + QUOTENAME(@UserName) + N';', N' GRANT VIEW DEFINITION ON SCHEMA::' + QUOTENAME(@Schema) + N' TO ' + QUOTENAME(@UserName) + N';');

            IF @CustomRoles IS NOT NULL AND LTRIM(RTRIM(@CustomRoles)) <> ''
            BEGIN
                DECLARE @Role NVARCHAR(128);
                DECLARE @RolesCursor CURSOR;
                SET @RolesCursor = CURSOR FOR SELECT LTRIM(RTRIM(value)) FROM STRING_SPLIT(@CustomRoles, ',');

                OPEN @RolesCursor;
                FETCH NEXT FROM @RolesCursor INTO @Role;
                WHILE @@FETCH_STATUS = 0
                BEGIN
                    SET @SQL += CHAR(10) + N' ALTER ROLE ' + QUOTENAME(@Role) + N' ADD MEMBER ' + QUOTENAME(@UserName) + N';';
                    FETCH NEXT FROM @RolesCursor INTO @Role;
                END
                CLOSE @RolesCursor;
                DEALLOCATE @RolesCursor;
            END

            IF @Print = 1 PRINT '--------------------------------------------------' + CHAR(13) + CHAR(10) + '-- Permissions for database: ' + @DBNameCursor + CHAR(13) + CHAR(10) + @SQL;
            IF @Execute = 1 EXEC sp_executesql @SQL;

            FETCH NEXT FROM db_cursor INTO @DBNameCursor;
        END

        CLOSE db_cursor;
        DEALLOCATE db_cursor;

    END TRY
    BEGIN CATCH
        IF CURSOR_STATUS('global', 'db_cursor') >= 0
        BEGIN
            CLOSE db_cursor;
            DEALLOCATE db_cursor;
        END
        DECLARE @ErrorMessage NVARCHAR(4000), @ErrorSeverity INT, @ErrorState INT;
        SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE();
        RAISERROR (@ErrorMessage, @ErrorSeverity, @ErrorState);
    END CATCH
END
GO

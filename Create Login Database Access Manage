USE tempdb
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE OR ALTER PROCEDURE dbo.usp_GrantAccess
    @UserName               NVARCHAR(128) = 'test_user',
    @Print                  BIT           = 1,
    @Execute                BIT           = 0,
    @Password               NVARCHAR(128) = NULL OUTPUT,
    @IsPasswordHashed       BIT           = 0,
    @SID                    VARBINARY(85) = NULL,
    @DBNames                NVARCHAR(MAX) = '', 
    @ExcludeDBs             NVARCHAR(MAX) = NULL,
    @IncludeSystemDBs       BIT           = 0,
    @Schema                 NVARCHAR(128) = NULL,
    @GrantRead              BIT           = 1,
    @GrantWrite             BIT           = 0,
    @GrantExecute           BIT           = 0,
    @GrantViewDefinition    BIT           = 0,
    @GrantViewServerState   BIT           = 0,
    @CustomRoles            NVARCHAR(MAX) = NULL,
    @Rollback               BIT           = 0,
    @CleanupLogin           BIT           = 0
AS
BEGIN
    SET NOCOUNT ON;

    /*******************************************************************************
usp_GrantAccess

Description:
    A comprehensive security utility to provision or decommission SQL Logins
    and Database Users across multiple databases.

Parameters:
    @UserName               The target Login and User name.
    @Print                  Displays the generated T-SQL commands.
    @Execute                Executes the generated T-SQL commands.
    @Password               OUTPUT: The generated password for SQL Logins.
    @IsPasswordHashed       Set to 1 if the @Password provided is already hashed.
    @SID                    Specifies a fixed SID (useful for AG/Mirroring setups).
    @DBNames                Comma-separated list of databases. Empty string = All.
    @ExcludeDBs             Comma-separated list of databases to ignore.
    @IncludeSystemDBs       Include 'master', 'msdb', and 'model'.
    @Schema                 If provided, grants permissions ONLY on this schema.
    @GrantRead              Grants db_datareader or SELECT on schema.
    @GrantWrite             Grants db_datawriter or INSERT/UPDATE/DELETE on schema.
    @GrantExecute           Grants EXECUTE at DB level or Schema level.
    @GrantViewDefinition    Grants VIEW DEFINITION.
    @GrantViewServerState   Grants VIEW SERVER STATE (Server-level permission).
    @CustomRoles            Comma-separated list of DB or Server roles to assign.
    @Rollback               1 = Decommissions the user (Revokes/Drops).
    @CleanupLogin           1 = Also drops the Server Login during Rollback.

--------------------------------------------------------------------------------
License: MIT
--------------------------------------------------------------------------------
*******************************************************************************/
    
    DECLARE @Results TABLE (
        UserName NVARCHAR(128),
        Scope NVARCHAR(128), 
        ActionTaken NVARCHAR(50), 
        Status NVARCHAR(20), 
        Message NVARCHAR(MAX)
    );
    DECLARE @SQL NVARCHAR(MAX);
    DECLARE @IsSqlLogin BIT = IIF(CHARINDEX('\', @UserName) = 0, 1, 0);

    --------------------------------------------------------------------------------
    -- PHASE 0: PREPARATION
    --------------------------------------------------------------------------------
    IF @Rollback = 0 AND @IsSqlLogin = 1 AND ISNULL(@Password, '') = ''
    BEGIN
        DECLARE @Chars VARCHAR(100) = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';
        SELECT @Password = (SELECT TOP 16 SUBSTRING(@Chars, 1 + ABS(CHECKSUM(CRYPT_GEN_RANDOM(4))) % LEN(@Chars), 1)
                            FROM sys.all_columns FOR XML PATH(''));
    END

    DECLARE @CleanRoles TABLE (RoleName SYSNAME, IsServerRole BIT);
    INSERT INTO @CleanRoles (RoleName, IsServerRole)
    SELECT LTRIM(RTRIM(value)), 
           IIF(EXISTS(SELECT 1 FROM sys.server_principals WHERE name = LTRIM(RTRIM(value)) AND type = 'R'), 1, 0)
    FROM STRING_SPLIT(ISNULL(@CustomRoles, ''), ',') WHERE value <> '';

    --------------------------------------------------------------------------------
    -- PHASE 1: SERVER LEVEL OPERATIONS
    --------------------------------------------------------------------------------
    BEGIN TRY
        IF @Rollback = 0
        BEGIN
            -- CREATE LOGIN
            IF NOT EXISTS (SELECT 1 FROM sys.server_principals WHERE name = @UserName)
            BEGIN
                SET @SQL = IIF(@IsSqlLogin = 1, 
                    N'CREATE LOGIN ' + QUOTENAME(@UserName) + N' WITH PASSWORD = ' + IIF(@IsPasswordHashed = 1, @Password + N' HASHED', N'''' + REPLACE(@Password, '''', '''''') + N'''') + ISNULL(N', SID = ' + CONVERT(NVARCHAR(100), @SID, 1), '') + N', CHECK_POLICY = ON;',
                    N'CREATE LOGIN ' + QUOTENAME(@UserName) + N' FROM WINDOWS;');
                IF @Print = 1 PRINT '-- Server Level: ' + @SQL; 
                IF @Execute = 1 EXEC sp_executesql @SQL;
                INSERT INTO @Results VALUES (@UserName, 'SERVER', 'CREATE_LOGIN', 'SUCCESS', 'Login ensured');
            END
            
            -- SERVER ROLES
            DECLARE @SRole SYSNAME;
            DECLARE curSR CURSOR LOCAL FAST_FORWARD FOR SELECT RoleName FROM @CleanRoles WHERE IsServerRole = 1;
            OPEN curSR; FETCH NEXT FROM curSR INTO @SRole;
            WHILE @@FETCH_STATUS = 0 BEGIN
                SET @SQL = N'ALTER SERVER ROLE ' + QUOTENAME(@SRole) + N' ADD MEMBER ' + QUOTENAME(@UserName) + N';';
                IF @Execute = 1 EXEC sp_executesql @SQL;
                FETCH NEXT FROM curSR INTO @SRole;
            END
            CLOSE curSR; DEALLOCATE curSR;
        END
        
        -- VIEW SERVER STATE
        IF @GrantViewServerState = 1
        BEGIN
            SET @SQL = IIF(@Rollback = 0, N'GRANT ', N'REVOKE ') + N'VIEW SERVER STATE TO ' + QUOTENAME(@UserName) + N';';
            IF @Execute = 1 EXEC sp_executesql @SQL;
        END
    END TRY
    BEGIN CATCH
        INSERT INTO @Results VALUES (@UserName, 'SERVER', 'SERVER_SETUP', 'FAILED', ERROR_MESSAGE());
    END CATCH

    --------------------------------------------------------------------------------
    -- PHASE 2: DATABASE LEVEL OPERATIONS
    --------------------------------------------------------------------------------
    DECLARE @DBName SYSNAME;
    DECLARE db_cursor CURSOR LOCAL FAST_FORWARD FOR
        SELECT name FROM sys.databases
        WHERE state_desc = 'ONLINE' AND user_access_desc = 'MULTI_USER'
          AND (@DBNames = '' OR name IN (SELECT LTRIM(RTRIM(value)) FROM STRING_SPLIT(@DBNames, ',')))
          AND (@ExcludeDBs IS NULL OR name NOT IN (SELECT LTRIM(RTRIM(value)) FROM STRING_SPLIT(@ExcludeDBs, ',')))
          AND (@IncludeSystemDBs = 1 OR (is_distributor = 0 AND name NOT IN ('master', 'model', 'msdb', 'tempdb')));

    OPEN db_cursor;
    FETCH NEXT FROM db_cursor INTO @DBName;

    WHILE @@FETCH_STATUS = 0
    BEGIN
        BEGIN TRY
            -- Check for Read-Only status before attempting any DB work
            IF DATABASEPROPERTYEX(@DBName, 'Updateability') = 'READ_ONLY'
                THROW 50001, 'Database is READ_ONLY. Cannot modify users.', 1;

            DECLARE @InnerSQL NVARCHAR(MAX) = N'USE ' + QUOTENAME(@DBName) + N';' + CHAR(10);
            
            IF @Rollback = 0
            BEGIN
                -- GRANT LOGIC
                SET @InnerSQL += N'IF NOT EXISTS (SELECT 1 FROM sys.database_principals WHERE name = ' + QUOTENAME(@UserName, '''') + N') CREATE USER ' + QUOTENAME(@UserName) + N' FOR LOGIN ' + QUOTENAME(@UserName) + N';' + CHAR(10);
                IF @GrantRead = 1 SET @InnerSQL += IIF(@Schema IS NULL, N'ALTER ROLE db_datareader ADD MEMBER ', N'GRANT SELECT ON SCHEMA::' + QUOTENAME(@Schema) + N' TO ') + QUOTENAME(@UserName) + N';' + CHAR(10);
                IF @GrantWrite = 1 SET @InnerSQL += IIF(@Schema IS NULL, N'ALTER ROLE db_datawriter ADD MEMBER ', N'GRANT INSERT, UPDATE, DELETE ON SCHEMA::' + QUOTENAME(@Schema) + N' TO ') + QUOTENAME(@UserName) + N';' + CHAR(10);
                IF @GrantExecute = 1 SET @InnerSQL += IIF(@Schema IS NULL, N'GRANT EXECUTE TO ', N'GRANT EXECUTE ON SCHEMA::' + QUOTENAME(@Schema) + N' TO ') + QUOTENAME(@UserName) + N';' + CHAR(10);
                
                SELECT @InnerSQL += N'IF EXISTS (SELECT 1 FROM sys.database_principals WHERE name = ' + QUOTENAME(RoleName, '''') + N' AND type = ''R'') ALTER ROLE ' + QUOTENAME(RoleName) + N' ADD MEMBER ' + QUOTENAME(@UserName) + N';' + CHAR(10)
                FROM @CleanRoles WHERE IsServerRole = 0;
            END
            ELSE
            BEGIN
                -- ROLLBACK LOGIC
                SET @InnerSQL += N'IF EXISTS (SELECT 1 FROM sys.database_principals WHERE name = ' + QUOTENAME(@UserName, '''') + N') BEGIN ' + CHAR(10);
                SET @InnerSQL += N'  IF EXISTS (SELECT 1 FROM sys.schemas WHERE principal_id = USER_ID(' + QUOTENAME(@UserName, '''') + N')) 
                                        THROW 51000, ''User owns a schema and cannot be dropped.'', 1;' + CHAR(10);
                SET @InnerSQL += N'  DROP USER ' + QUOTENAME(@UserName) + N';' + CHAR(10);
                SET @InnerSQL += N'END';
            END

            IF @Print = 1 PRINT '-- DB: ' + @DBName + CHAR(10) + @InnerSQL;
            IF @Execute = 1 EXEC sp_executesql @InnerSQL;
            INSERT INTO @Results VALUES (@UserName, @DBName, 'DB_ACCESS', 'SUCCESS', IIF(@Rollback=0, 'Permissions Processed', 'User Dropped'));
        END TRY
        BEGIN CATCH
            INSERT INTO @Results VALUES (@UserName, @DBName, 'DB_ACCESS', 'FAILED', ERROR_MESSAGE());
        END CATCH
        FETCH NEXT FROM db_cursor INTO @DBName;
    END
    CLOSE db_cursor; DEALLOCATE db_cursor;

    --------------------------------------------------------------------------------
    -- PHASE 3: CLEANUP LOGIN (Always attempt if requested)
    --------------------------------------------------------------------------------
    IF @Rollback = 1 AND @CleanupLogin = 1
    BEGIN
        BEGIN TRY
            IF EXISTS (SELECT 1 FROM sys.server_principals WHERE name = @UserName)
            BEGIN
                SET @SQL = N'DROP LOGIN ' + QUOTENAME(@UserName) + N';';
                IF @Print = 1 PRINT '-- Server Cleanup: ' + @SQL;
                IF @Execute = 1 EXEC sp_executesql @SQL;
                INSERT INTO @Results VALUES (@UserName, 'SERVER', 'DROP_LOGIN', 'SUCCESS', 'Login removed');
            END
        END TRY
        BEGIN CATCH
            -- If this fails, it's usually because a User still exists in a DB we couldn't access (like a Read-Only AG secondary)
            INSERT INTO @Results VALUES (@UserName, 'SERVER', 'DROP_LOGIN', 'FAILED', ERROR_MESSAGE());
        END CATCH
    END

    -- Final Report
    IF @Print = 1 AND @Rollback = 0 AND @IsSqlLogin = 1 PRINT '-- Generated Password: ' + ISNULL(@Password, 'N/A');
    SELECT @UserName UserName, Scope, ActionTaken, Status, Message FROM @Results ORDER BY Scope ASC;
END
GO
EXEC usp_GrantAccess

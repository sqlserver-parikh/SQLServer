USE tempdb
GO
CREATE OR ALTER PROCEDURE dbo.usp_GrantAccess
    @UserName NVARCHAR(128) = 'domain\username',
    @Print BIT = 1,
    @Execute BIT = 0,
    @Password NVARCHAR(128) = NULL OUTPUT,
    @IsPasswordHashed BIT = 0,
    @SID VARBINARY(85) = NULL,
    @DBNames NVARCHAR(MAX) = '', 
    @ExcludeDBs NVARCHAR(MAX) = NULL,
    @IncludeSystemDBs BIT = 0,
    @Schema NVARCHAR(128) = NULL,
    @GrantRead BIT = 1,
    @GrantWrite BIT = 0,
    @GrantExecute BIT = 1,
    @GrantViewDefinition BIT = 0,
    @GrantViewServerState BIT = 0,
    @CustomRoles NVARCHAR(MAX) = 'db_ddladmin'
AS
BEGIN
    SET NOCOUNT ON;
    -- Fix for XML/Filtered Index errors
    SET ANSI_NULLS ON; SET ANSI_WARNINGS ON; SET QUOTED_IDENTIFIER ON;

    DECLARE @Results TABLE (DBName SYSNAME, Status NVARCHAR(20), Message NVARCHAR(MAX));
    DECLARE @SQL NVARCHAR(MAX);
    DECLARE @IsSqlLogin BIT = IIF(CHARINDEX('\', @UserName) = 0, 1, 0);
    DECLARE @ExistingName SYSNAME;
    DECLARE @ResolvedSID VARBINARY(85) = @SID;

    --------------------------------------------------------------------------------
    -- 1. SERVER LEVEL: IDENTITY RESOLUTION (AD Name Change)
    --------------------------------------------------------------------------------
    BEGIN TRY
        IF @IsSqlLogin = 0
        BEGIN
            SET @ResolvedSID = SUSER_SID(@UserName);
            SELECT @ExistingName = [name] FROM sys.server_principals WHERE [sid] = @ResolvedSID;

            IF @ExistingName IS NOT NULL AND @ExistingName <> @UserName
            BEGIN
                SET @SQL = N'ALTER LOGIN ' + QUOTENAME(@ExistingName) + N' WITH NAME = ' + QUOTENAME(@UserName) + N';';
                IF @Print = 1 PRINT '-- INFO: AD Rename detected. Mapping SID ' + CONVERT(NVARCHAR(100), @ResolvedSID, 1) + ' to new name.' + CHAR(10) + @SQL + CHAR(10);
                IF @Execute = 1 EXEC sp_executesql @SQL;
            END
        END

        IF NOT EXISTS (SELECT 1 FROM sys.server_principals WHERE name = @UserName)
        BEGIN
            IF @IsSqlLogin = 1
            BEGIN
                IF ISNULL(@Password, '') = '' SET @Password = REPLACE(CAST(NEWID() AS NVARCHAR(36)), '-', '') + 'A1!a';
                SET @SQL = N'CREATE LOGIN ' + QUOTENAME(@UserName) + N' WITH PASSWORD = ' +
                    IIF(@IsPasswordHashed = 1, @Password + N' HASHED', N'''' + REPLACE(@Password, '''', '''''') + N'''') + 
                    ISNULL(N', SID = ' + CONVERT(NVARCHAR(100), @SID, 1), N'') + N', CHECK_POLICY = OFF;';
            END
            ELSE
            BEGIN
                SET @SQL = N'CREATE LOGIN ' + QUOTENAME(@UserName) + N' FROM WINDOWS;';
            END
            IF @Print = 1 PRINT @SQL;
            IF @Execute = 1 EXEC sp_executesql @SQL;
        END

        -- SERVER ROLES
        DECLARE @RoleName NVARCHAR(128);
        DECLARE curR CURSOR LOCAL FAST_FORWARD FOR SELECT LTRIM(RTRIM(value)) FROM STRING_SPLIT(@CustomRoles, ',');
        OPEN curR; FETCH NEXT FROM curR INTO @RoleName;
        WHILE @@FETCH_STATUS = 0
        BEGIN
            IF EXISTS (SELECT 1 FROM sys.server_principals WHERE name = @RoleName AND type = 'R')
            BEGIN
                SET @SQL = N'ALTER SERVER ROLE ' + QUOTENAME(@RoleName) + N' ADD MEMBER ' + QUOTENAME(@UserName) + N';';
                IF @Print = 1 PRINT @SQL;
                IF @Execute = 1 EXEC sp_executesql @SQL;
            END
            FETCH NEXT FROM curR INTO @RoleName;
        END
        CLOSE curR; DEALLOCATE curR;

        IF @GrantViewServerState = 1
        BEGIN
            SET @SQL = N'GRANT VIEW SERVER STATE TO ' + QUOTENAME(@UserName) + N';';
            IF @Print = 1 PRINT @SQL;
            IF @Execute = 1 EXEC sp_executesql @SQL;
        END
    END TRY
    BEGIN CATCH
        INSERT INTO @Results (DBName, Status, Message) VALUES ('SERVER_LEVEL', 'FAILED', ERROR_MESSAGE());
    END CATCH

    --------------------------------------------------------------------------------
    -- 2. DATABASE LEVEL: USER & ROLE ASSIGNMENT
    --------------------------------------------------------------------------------
    DECLARE @DBName SYSNAME;
    DECLARE db_cursor CURSOR LOCAL FAST_FORWARD FOR
        SELECT name FROM sys.databases
        WHERE state_desc = 'ONLINE'
          AND (@DBNames = '' OR name IN (SELECT LTRIM(RTRIM(value)) FROM STRING_SPLIT(@DBNames, ',')))
          AND (@ExcludeDBs IS NULL OR name NOT IN (SELECT LTRIM(RTRIM(value)) FROM STRING_SPLIT(@ExcludeDBs, ',')))
          AND (@IncludeSystemDBs = 1 OR (is_distributor = 0 AND name NOT IN ('master', 'model', 'msdb', 'tempdb')));

    OPEN db_cursor;
    FETCH NEXT FROM db_cursor INTO @DBName;

    WHILE @@FETCH_STATUS = 0
    BEGIN
        BEGIN TRY
            IF DATABASEPROPERTYEX(@DBName, 'Updateability') = 'READ_ONLY'
                THROW 50001, 'Database is READ_ONLY.', 1;

            -- 2a. User Creation
            SET @SQL = N'USE ' + QUOTENAME(@DBName) + N';' + CHAR(10) +
                       N'IF NOT EXISTS (SELECT 1 FROM sys.database_principals WHERE name = ' + QUOTENAME(@UserName, '''') + N')' + CHAR(10) +
                       N'    CREATE USER ' + QUOTENAME(@UserName) + N' FOR LOGIN ' + QUOTENAME(@UserName) + N';' + CHAR(10) +
                       N'ELSE ALTER USER ' + QUOTENAME(@UserName) + N' WITH LOGIN = ' + QUOTENAME(@UserName) + N';' + CHAR(10);

            -- 2b. Standard Permissions (Schema aware)
            IF @GrantRead = 1
                SET @SQL += IIF(@Schema IS NULL, N'ALTER ROLE db_datareader ADD MEMBER ' + QUOTENAME(@UserName) + N';' + CHAR(10), 
                            N'IF EXISTS (SELECT 1 FROM sys.schemas WHERE name = ' + QUOTENAME(@Schema, '''') + N') GRANT SELECT ON SCHEMA::' + QUOTENAME(@Schema) + N' TO ' + QUOTENAME(@UserName) + N';' + CHAR(10));
            IF @GrantWrite = 1
                SET @SQL += IIF(@Schema IS NULL, N'ALTER ROLE db_datawriter ADD MEMBER ' + QUOTENAME(@UserName) + N';' + CHAR(10), 
                            N'IF EXISTS (SELECT 1 FROM sys.schemas WHERE name = ' + QUOTENAME(@Schema, '''') + N') GRANT INSERT, UPDATE, DELETE ON SCHEMA::' + QUOTENAME(@Schema) + N' TO ' + QUOTENAME(@UserName) + N';' + CHAR(10));
            IF @GrantExecute = 1
                SET @SQL += IIF(@Schema IS NULL, N'GRANT EXECUTE TO ' + QUOTENAME(@UserName) + N';' + CHAR(10), 
                            N'IF EXISTS (SELECT 1 FROM sys.schemas WHERE name = ' + QUOTENAME(@Schema, '''') + N') GRANT EXECUTE ON SCHEMA::' + QUOTENAME(@Schema) + N' TO ' + QUOTENAME(@UserName) + N';' + CHAR(10));

            -- 2c. Custom DB Roles (Built outside the dynamic string to avoid syntax errors)
            DECLARE @DBRoleName NVARCHAR(128);
            DECLARE curDBR CURSOR LOCAL FAST_FORWARD FOR SELECT LTRIM(RTRIM(value)) FROM STRING_SPLIT(@CustomRoles, ',');
            OPEN curDBR; FETCH NEXT FROM curDBR INTO @DBRoleName;
            WHILE @@FETCH_STATUS = 0
            BEGIN
                -- Build the check: only if it's a DB Role and NOT a Server Role
                SET @SQL += N'IF EXISTS (SELECT 1 FROM sys.database_principals WHERE name = ' + QUOTENAME(@DBRoleName, '''') + N' AND type = ''R'') ' +
                            N'AND NOT EXISTS (SELECT 1 FROM sys.server_principals WHERE name = ' + QUOTENAME(@DBRoleName, '''') + N' AND type = ''R'') ' +
                            N'BEGIN ALTER ROLE ' + QUOTENAME(@DBRoleName) + N' ADD MEMBER ' + QUOTENAME(@UserName) + N'; END' + CHAR(10);
                FETCH NEXT FROM curDBR INTO @DBRoleName;
            END
            CLOSE curDBR; DEALLOCATE curDBR;

            IF @Print = 1 
            BEGIN
                PRINT '-- START DB: ' + @DBName;
                PRINT @SQL;
                PRINT '-- END DB: ' + @DBName + CHAR(10);
            END

            IF @Execute = 1 EXEC sp_executesql @SQL;
            INSERT INTO @Results (DBName, Status, Message) VALUES (@DBName, 'SUCCESS', 'Applied');
        END TRY
        BEGIN CATCH
            INSERT INTO @Results (DBName, Status, Message) VALUES (@DBName, 'FAILED', ERROR_MESSAGE());
        END CATCH

        FETCH NEXT FROM db_cursor INTO @DBName;
    END

    CLOSE db_cursor; DEALLOCATE db_cursor;

    --------------------------------------------------------------------------------
    -- 3. FINAL SUMMARY
    --------------------------------------------------------------------------------
    PRINT '--==================================================';
    PRINT '--FINAL EXECUTION SUMMARY';
    PRINT '--==================================================';
    SELECT * FROM @Results;
END
GO
usp_GrantAccess

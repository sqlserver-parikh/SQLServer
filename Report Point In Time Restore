USE tempdb;
GO

CREATE OR ALTER PROCEDURE usp_PointInTimeRestore
    @DBName NVARCHAR(128) = '', -- If NULL or Blank, then all databases
    @PointInTime DATETIME = NULL,
    @GenerateRestoreScript BIT = 1,
    @DatabaseGUID UNIQUEIDENTIFIER = NULL -- Optional: filter by specific database GUID
AS
BEGIN
    SET NOCOUNT ON;

    IF @DBName = '' SET @DBName = NULL;

    -- Cleanup temp tables if they exist
    DROP TABLE IF EXISTS #AGInfo, #BackupSetIDs, #BackupDetails, #RestoreBase;

    -- Backup tracking table
    CREATE TABLE #BackupSetIDs (
        DBName NVARCHAR(128),
        DatabaseGUID UNIQUEIDENTIFIER,
        LastFullBackupID INT,
        LastFullBackupSetUUID UNIQUEIDENTIFIER, -- Using UUID for the full backup
        LastDifferentialBackupID INT,
        BackupServer NVARCHAR(128),
        IsInRestorePlan BIT DEFAULT 1
    );

    -- Backup details table
    CREATE TABLE #BackupDetails (
        DBName NVARCHAR(128),
        DatabaseGUID UNIQUEIDENTIFIER,
        BackupFileLocation NVARCHAR(260),
        BackupStartDate DATETIME,
        EndDate DATETIME,
        BackupType NVARCHAR(50),
        BackupSizeMB FLOAT,
        BackupServer NVARCHAR(128),
        BackupSetId INT,
        MediaSetId INT,
        FileNumber INT,
        AGName NVARCHAR(128) NULL,
        IsPrimaryBackup BIT NULL,
        BackupPreference NVARCHAR(60) NULL,
        AvailabilityMode NVARCHAR(60) NULL,
        RestoreWarning NVARCHAR(MAX) NULL,
        IsInRestorePlan BIT DEFAULT 1
    );

    -- AG info table
    CREATE TABLE #AGInfo (
        AGName NVARCHAR(128),
        ListenerName NVARCHAR(63),
        ReplicaServer NVARCHAR(256),
        DatabaseName NVARCHAR(128),
        IsPrimaryServer BIT,
        ReadableSecondary NVARCHAR(60),
        AvailabilityMode NVARCHAR(60),
        FailoverMode NVARCHAR(60),
        BackupPreference NVARCHAR(60),
        PrimaryReplicaServer NVARCHAR(256)
    );

    DECLARE @IsHadrEnabled BIT = CONVERT(BIT, SERVERPROPERTY('IsHadrEnabled'));

    -- Populate AG info if HADR is enabled
    IF @IsHadrEnabled = 1
    BEGIN
        INSERT INTO #AGInfo (
            AGName, ListenerName, ReplicaServer, DatabaseName, 
            IsPrimaryServer, ReadableSecondary, AvailabilityMode, FailoverMode
        )
        SELECT 
            ag.name,
            agl.dns_name,
            ar.replica_server_name,
            adc.database_name,
            CASE WHEN ags.primary_replica = ar.replica_server_name THEN 1 ELSE 0 END,
            ar.secondary_role_allow_connections_desc,
            ar.availability_mode_desc,
            ar.failover_mode_desc
        FROM sys.availability_groups ag
        JOIN sys.availability_replicas ar ON ag.group_id = ar.group_id
        JOIN sys.dm_hadr_availability_group_states ags ON ag.group_id = ags.group_id
        JOIN sys.availability_databases_cluster adc ON adc.group_id = ag.group_id
        LEFT JOIN sys.availability_group_listeners agl ON agl.group_id = ag.group_id
        WHERE (@DBName IS NULL OR adc.database_name = @DBName);

        UPDATE #AGInfo
        SET 
            BackupPreference = ag.automated_backup_preference_desc,
            PrimaryReplicaServer = ags.primary_replica
        FROM #AGInfo agi
        JOIN sys.availability_groups ag ON agi.AGName = ag.name
        JOIN sys.dm_hadr_availability_group_states ags ON ag.group_id = ags.group_id;
    END

    -- Get latest full backup
    INSERT INTO #BackupSetIDs (DBName, DatabaseGUID, LastFullBackupID, LastFullBackupSetUUID, BackupServer)
    SELECT 
        bs.database_name,
        bs.database_guid,
        bs.backup_set_id,
        bs.backup_set_uuid, -- Correctly using backup_set_uuid
        bs.server_name
    FROM msdb.dbo.backupset bs
    WHERE bs.type = 'D'
        AND bs.backup_finish_date <= ISNULL(@PointInTime, bs.backup_finish_date)
        AND (@DBName IS NULL OR bs.database_name = @DBName)
        AND (@DatabaseGUID IS NULL OR bs.database_guid = @DatabaseGUID)
        AND bs.is_copy_only = 0
        AND bs.backup_start_date = (
            SELECT MAX(backup_start_date)
            FROM msdb.dbo.backupset bs2
            WHERE bs2.database_name = bs.database_name
                AND bs2.database_guid = bs.database_guid
                AND bs2.type = 'D'
                AND bs2.backup_finish_date <= ISNULL(@PointInTime, bs2.backup_finish_date)
                AND bs2.is_copy_only = 0
        );

    -- Get latest differential backup based on the full backup
    UPDATE bsi
    SET LastDifferentialBackupID = (
        SELECT TOP 1 bs.backup_set_id
        FROM msdb.dbo.backupset bs
        WHERE bs.type = 'I'
            AND bs.backup_finish_date <= ISNULL(@PointInTime, bs.backup_finish_date)
            -- *** CORRECTION: Using differential_base_guid as reported by user ***
            AND bs.differential_base_guid = bsi.LastFullBackupSetUUID
            AND bs.database_guid = bsi.DatabaseGUID
            AND bs.is_copy_only = 0
        ORDER BY bs.backup_finish_date DESC
    )
    FROM #BackupSetIDs bsi;
    
    -- Insert full and differential backups
    INSERT INTO #BackupDetails
    SELECT 
        bs.database_name,
        bs.database_guid,
        bmf.physical_device_name,
        bs.backup_start_date,
        bs.backup_finish_date,
        CASE bs.type WHEN 'D' THEN 'Full' WHEN 'I' THEN 'Differential' ELSE 'Log' END,
        bs.backup_size / 1024.0 / 1024.0,
        bs.server_name,
        bs.backup_set_id,
        bmf.media_set_id,
        bmf.family_sequence_number,
        ag.AGName,
        CASE WHEN ag.PrimaryReplicaServer = bs.server_name THEN 1 ELSE 0 END,
        ag.BackupPreference,
        ag.AvailabilityMode,
        NULL,
        1
    FROM msdb.dbo.backupset bs
    JOIN msdb.dbo.backupmediafamily bmf ON bs.media_set_id = bmf.media_set_id
    JOIN #BackupSetIDs bsi ON bs.backup_set_id IN (bsi.LastFullBackupID, bsi.LastDifferentialBackupID)
        AND bs.database_guid = bsi.DatabaseGUID
    LEFT JOIN #AGInfo ag ON bs.database_name = ag.DatabaseName;

    -- Determine the end time of the last full or differential restore base.
    SELECT
        bsi.DatabaseGUID,
        MAX(bs.backup_finish_date) AS BaseFinishTime
    INTO #RestoreBase
    FROM #BackupSetIDs bsi
    JOIN msdb.dbo.backupset bs ON bs.database_guid = bsi.DatabaseGUID
        AND bs.backup_set_id IN (bsi.LastFullBackupID, bsi.LastDifferentialBackupID)
    GROUP BY bsi.DatabaseGUID;

    -- Select all log backups from the end of our base restore until the point in time.
    INSERT INTO #BackupDetails
    SELECT 
        bs.database_name,
        bs.database_guid,
        bmf.physical_device_name,
        bs.backup_start_date,
        bs.backup_finish_date,
        'Log',
        bs.backup_size / 1024.0 / 1024.0,
        bs.server_name,
        bs.backup_set_id,
        bmf.media_set_id,
        bmf.family_sequence_number,
        ag.AGName,
        CASE WHEN ag.PrimaryReplicaServer = bs.server_name THEN 1 ELSE 0 END,
        ag.BackupPreference,
        ag.AvailabilityMode,
        NULL,
        1
    FROM msdb.dbo.backupset bs
    JOIN msdb.dbo.backupmediafamily bmf ON bs.media_set_id = bmf.media_set_id
    JOIN #BackupSetIDs bsi ON bs.database_name = bsi.DBName AND bs.database_guid = bsi.DatabaseGUID
    JOIN #RestoreBase rb ON bsi.DatabaseGUID = rb.DatabaseGUID
    LEFT JOIN #AGInfo ag ON bs.database_name = ag.DatabaseName
    WHERE bs.type = 'L'
      AND bs.backup_finish_date > rb.BaseFinishTime
      AND bs.backup_start_date <= ISNULL(@PointInTime, bs.backup_start_date);

    -- Generate restore scripts
    IF @GenerateRestoreScript = 1
    BEGIN
        -- Aggregate striped backup files into a single RESTORE command
        ;WITH BackupFileGroups AS (
            SELECT
                DBName,
                DatabaseGUID,
                BackupSetId,
                BackupType,
                BackupStartDate,
                EndDate,
                STRING_AGG(
                    CAST(
                        CASE
                            WHEN BackupFileLocation LIKE 'http%' THEN 'URL = N'''
                            ELSE 'DISK = N'''
                        END + BackupFileLocation + '''' AS NVARCHAR(MAX)
                    ),
                    ',' + CHAR(13) + CHAR(10) + '    '
                ) WITHIN GROUP (ORDER BY FileNumber) AS DeviceClauses,
                SUM(BackupSizeMB) AS TotalBackupSizeMB,
                MAX(ISNULL(RestoreWarning, '')) AS RestoreWarnings
            FROM
                #BackupDetails
            WHERE IsInRestorePlan = 1
            GROUP BY
                DBName, DatabaseGUID, BackupSetId, BackupType, BackupStartDate, EndDate
        )
        -- Generate the restore script using the aggregated file groups
        SELECT 
            ROW_NUMBER() OVER (PARTITION BY bf.DatabaseGUID ORDER BY bf.BackupStartDate) AS StepNumber,
            bf.DBName,
            bf.DatabaseGUID,
            CASE
                WHEN bf.BackupType IN ('Full', 'Differential') THEN
                    'RESTORE DATABASE [' + bf.DBName + '] FROM ' + CHAR(13) + CHAR(10) + '    ' + bf.DeviceClauses + CHAR(13) + CHAR(10) + 'WITH NORECOVERY;'
                WHEN bf.BackupType = 'Log' THEN
                    'RESTORE LOG [' + bf.DBName + '] FROM ' + CHAR(13) + CHAR(10) + '    ' + bf.DeviceClauses + CHAR(13) + CHAR(10) +
                    CASE
                        WHEN @PointInTime IS NOT NULL AND bf.EndDate >= @PointInTime AND bf.BackupStartDate < @PointInTime THEN
                            'WITH STOPAT = ''' + CONVERT(VARCHAR(23), @PointInTime, 121) + ''', NORECOVERY;'
                        ELSE
                            'WITH NORECOVERY;'
                    END
            END AS RestoreCommand,
            bf.BackupType,
            bf.BackupStartDate,
            bf.EndDate,
            bf.TotalBackupSizeMB AS BackupSizeMB,
            bf.RestoreWarnings,
            CONVERT(VARCHAR(23), @PointInTime, 121) AS EffectiveRestoreTime
        FROM BackupFileGroups bf

        UNION ALL

        -- Final recovery step per database GUID
        SELECT 
            99999,
            -- *** CORRECTION: Qualify columns with the subquery alias 'FinalSteps' ***
            FinalSteps.DBName,
            FinalSteps.DatabaseGUID,
            'RESTORE DATABASE [' + FinalSteps.DBName + '] WITH RECOVERY;',
            'Recovery',
            GETDATE(),
            GETDATE(),
            NULL,
            NULL,
            CONVERT(VARCHAR(23), @PointInTime, 121)
        FROM (
            SELECT DISTINCT DBName, DatabaseGUID
            FROM #BackupDetails
            WHERE IsInRestorePlan = 1
        ) AS FinalSteps

        ORDER BY DBName, DatabaseGUID, StepNumber;
    END
    ELSE
    BEGIN
        -- Return backup details with AG info
        SELECT 
            bd.DBName,
            bd.DatabaseGUID,
            bd.BackupFileLocation,
            bd.BackupStartDate,
            bd.EndDate,
            bd.BackupType,
            bd.BackupSizeMB,
            bd.BackupServer,
            bd.AGName,
            ag.ListenerName,
            ag.PrimaryReplicaServer AS CurrentPrimary,
            bd.IsPrimaryBackup,
            bd.BackupPreference,
            bd.AvailabilityMode,
            ag.ReadableSecondary,
            bd.RestoreWarning,
            bd.FileNumber,
            CASE 
                WHEN @IsHadrEnabled = 1 AND ag.AGName IS NOT NULL THEN
                    CASE 
                        WHEN bd.BackupServer <> ag.PrimaryReplicaServer THEN 
                            'Backup from secondary replica: ' + bd.BackupServer
                        WHEN ag.BackupPreference = 'SECONDARY_ONLY' AND bd.BackupServer = ag.PrimaryReplicaServer 
                            THEN 'Warning: Backup from primary when preference is secondary only'
                        ELSE NULL
                    END
                ELSE NULL
            END AS AGWarning,
            CONVERT(VARCHAR(23), @PointInTime, 121) AS EffectiveRestoreTime
        FROM #BackupDetails bd
        LEFT JOIN #AGInfo ag ON bd.DBName = ag.DatabaseName
        WHERE bd.IsInRestorePlan = 1
        ORDER BY bd.DBName, bd.DatabaseGUID, bd.BackupStartDate;
    END

    -- Cleanup
    DROP TABLE IF EXISTS #AGInfo, #BackupSetIDs, #BackupDetails, #RestoreBase;
END;
GO

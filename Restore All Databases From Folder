USE [master];
GO
SET ANSI_NULLS ON;
GO
SET QUOTED_IDENTIFIER ON;
GO

CREATE OR ALTER PROCEDURE [dbo].[sp_RestoreFromAllFilesInDirectory_v2]
    -- Core Parameters
      @BackupFileLocations NVARCHAR(MAX) -- Comma-separated list of paths to search for .bak files. e.g., 'U:\,V:\Backups'
    , @DataFileLocations   NVARCHAR(MAX) -- Comma-separated list of destination data file paths. e.g., 'J:\SQLData\,K:\SQLData\'
    , @LogFileLocations    NVARCHAR(MAX) -- Comma-separated list of destination log file paths. e.g., 'L:\SQLLogs\'
    -- Filtering and Behavior Control
    , @DatabaseName        NVARCHAR(128) = NULL -- Optional: Restore only a specific database. If NULL, restores the first valid backup found in each file.
    , @BackupInLastXDays   INT           = 7    -- Only consider backups taken within the last X days.
    , @MaxBackupSizeInGB   INT           = 500  -- Maximum compressed backup size in GB to consider.
    -- Execution Options
    , @PrintOnly           BIT           = 1    -- 1: Print commands. 0: Execute commands.
    , @RunRecovery         BIT           = 1    -- 1: RESTORE WITH RECOVERY. 0: RESTORE WITH NORECOVERY.
    , @RunCheckDB          BIT           = 1    -- After a successful restore, run DBCC CHECKDB.
    -- Dangerous Options - USE WITH EXTREME CAUTION
    , @DropExistingDatabase BIT          = 0    -- If 1, will attempt to SET the database to SINGLE_USER and DROP it before restoring.
    , @DeleteBackupFile    BIT           = 0    -- If 1, will delete the backup file(s) AFTER a successful restore and CHECKDB.
    -- Performance Tuning
    , @BufferCount         INT           = NULL
    , @MaxTransferSize     INT           = NULL
    , @BlockSize           INT           = NULL
AS
/*
========================================================================================================================
Description:    Restores the most recent, valid full backup for databases found in specified locations.
                This version uses comma-separated paths for flexibility and includes robust error handling.

Author:         (Refactored from original)
Version:        2.0

Usage Example:
EXEC [dbo].[sp_RestoreFromAllFilesInDirectory_v2]
      @BackupFileLocations = N'U:\Backups\Daily,V:\Backups\Daily'
    , @DataFileLocations   = N'J:\SQLData\,K:\SQLData\,M:\SQLData\' -- Data files will be distributed round-robin across these paths.
    , @LogFileLocations    = N'I:\SQLLogs\'
    , @BackupInLastXDays   = 30
    , @MaxBackupSizeInGB   = 1000
    , @PrintOnly           = 0
    , @RunRecovery         = 1
    , @RunCheckDB          = 1
    , @DropExistingDatabase= 1  -- CAUTION!
    , @DeleteBackupFile    = 0  -- CAUTION!
    , @BufferCount         = 24
    , @MaxTransferSize     = 4194304
    , @BlockSize           = 65536;
========================================================================================================================
*/
BEGIN
    SET NOCOUNT ON;

    -- =================================================================================================================
    -- Input Validation
    -- =================================================================================================================
    IF @BackupFileLocations IS NULL OR LTRIM(RTRIM(@BackupFileLocations)) = ''
    BEGIN
        THROW 50001, N'The @BackupFileLocations parameter cannot be empty.', 1;
    END;
    IF @DataFileLocations IS NULL OR LTRIM(RTRIM(@DataFileLocations)) = ''
    BEGIN
        THROW 50002, N'The @DataFileLocations parameter cannot be empty.', 1;
    END;
    IF @LogFileLocations IS NULL OR LTRIM(RTRIM(@LogFileLocations)) = ''
    BEGIN
        THROW 50003, N'The @LogFileLocations parameter cannot be empty.', 1;
    END;

    IF @MaxTransferSize > 4194304
        THROW 50004, N'@MaxTransferSize cannot be greater than 4194304.', 1;

    IF @MaxTransferSize % 65536 <> 0
        THROW 50005, N'@MaxTransferSize must be a multiple of 65536.', 1;

    IF @BlockSize IS NOT NULL AND @BlockSize NOT IN (512, 1024, 2048, 4096, 8192, 16384, 32768, 65536)
        THROW 50006, N'Supported values for @BlockSize are 512, 1024, 2048, 4096, 8192, 16384, 32768, and 65536.', 1;

    -- =================================================================================================================
    -- Prepare Environment and Temp Tables
    -- =================================================================================================================
    DECLARE @sql NVARCHAR(MAX), @crlf NCHAR(2) = NCHAR(13) + NCHAR(10);
    DECLARE @StartTime DATETIME, @DbName SYSNAME, @RestoreCommand NVARCHAR(MAX), @BackupFile VARCHAR(1000);
    DECLARE @ErrorMessage NVARCHAR(4000), @ErrorSeverity INT, @ErrorState INT;

    -- Ensure logging table exists
    IF OBJECT_ID('master.dbo.CommandLog') IS NULL
    BEGIN
        PRINT 'Creating master.dbo.CommandLog for logging...';
        CREATE TABLE master.dbo.CommandLog (
            ID INT IDENTITY(1,1) PRIMARY KEY, DatabaseName NVARCHAR(128), CommandType NVARCHAR(60),
            Command NVARCHAR(MAX), StartTime DATETIME, EndTime DATETIME,
            ErrorNumber INT, ErrorMessage NVARCHAR(MAX)
        );
    END

    -- Parse comma-separated paths into tables for easy round-robin access
    CREATE TABLE #DataPaths (ID INT IDENTITY(1,1), PathValue NVARCHAR(500));
    INSERT INTO #DataPaths (PathValue) SELECT LTRIM(RTRIM(value)) FROM STRING_SPLIT(@DataFileLocations, ',');

    CREATE TABLE #LogPaths (ID INT IDENTITY(1,1), PathValue NVARCHAR(500));
    INSERT INTO #LogPaths (PathValue) SELECT LTRIM(RTRIM(value)) FROM STRING_SPLIT(@LogFileLocations, ',');

    DECLARE @TotalDataPaths INT = @@ROWCOUNT, @TotalLogPaths INT;
    SELECT @TotalLogPaths = COUNT(*) FROM #LogPaths;

    IF @TotalDataPaths = 0 THROW 50007, N'No valid data file paths were provided in @DataFileLocations.', 1;
    IF @TotalLogPaths = 0 THROW 50008, N'No valid log file paths were provided in @LogFileLocations.', 1;

    -- Find all .bak files in the specified locations
    CREATE TABLE #BackupFiles (FullPath NVARCHAR(1000));
    INSERT INTO #BackupFiles (FullPath)
    SELECT f.full_filesystem_path
    FROM STRING_SPLIT(@BackupFileLocations, ',') AS s
    CROSS APPLY sys.dm_os_enumerate_filesystem(s.value, '*.bak') AS f
    WHERE f.is_directory = 0;

    -- Universal temp tables for RESTORE command results (will work across versions)
    CREATE TABLE #RestoreHeader (
        BackupName              NVARCHAR(128), BackupDescription       NVARCHAR(255), BackupType              SMALLINT,
        ExpirationDate          DATETIME,      Compressed              TINYINT,       Position                SMALLINT,
        DeviceType              TINYINT,       UserName                NVARCHAR(128), ServerName              NVARCHAR(128),
        DatabaseName            NVARCHAR(128), DatabaseVersion         INT,           DatabaseCreationDate    DATETIME,
        BackupSize              NUMERIC(20,0), FirstLSN                NUMERIC(25,0), LastLSN                 NUMERIC(25,0),
        CheckpointLSN           NUMERIC(25,0), DatabaseBackupLSN       NUMERIC(25,0), BackupStartDate         DATETIME,
        BackupFinishDate        DATETIME,      SortOrder               SMALLINT,      CodePage                SMALLINT,
        UnicodeLocaleId         INT,           UnicodeComparisonStyle  INT,           CompatibilityLevel      TINYINT,
        SoftwareVendorId        INT,           SoftwareVersionMajor    INT,           SoftwareVersionMinor    INT,
        SoftwareVersionBuild    INT,           MachineName             NVARCHAR(128), Flags                   INT,
        BindingID               UNIQUEIDENTIFIER, RecoveryForkID       UNIQUEIDENTIFIER, Collation            NVARCHAR(128),
        FamilyGUID              UNIQUEIDENTIFIER, HasBulkLoggedData    BIT,           IsSnapshot              BIT,
        IsReadOnly              BIT,           IsSingleUser            BIT,           HasBackupChecksums      BIT,
        IsDamaged               BIT,           BeginsLogChain          BIT,           HasIncompleteMetaData   BIT,
        IsForceOffline          BIT,           IsCopyOnly              BIT,           FirstRecoveryForkID     UNIQUEIDENTIFIER,
        ForkPointLSN            NUMERIC(25,0), RecoveryModel           NVARCHAR(60),  DifferentialBaseLSN     NUMERIC(25,0),
        DifferentialBaseGUID    UNIQUEIDENTIFIER, BackupTypeDescription NVARCHAR(60),  BackupSetGUID         UNIQUEIDENTIFIER,
        CompressedBackupSize    BIGINT,        Containment             TINYINT,       KeyAlgorithm            NVARCHAR(32),
        EncryptorThumbprint     VARBINARY(20), EncryptorType           NVARCHAR(32),  LastValidRestoreTime    DATETIME,
        TimeZone                NVARCHAR(30),  CompressionAlgorithm    NVARCHAR(10)
    );

    CREATE TABLE #FileList (
        LogicalName          NVARCHAR(128), PhysicalName         NVARCHAR(260), [Type]               CHAR(1),
        FileGroupName        NVARCHAR(128), Size                 NUMERIC(20,0), MaxSize              NUMERIC(20,0),
        FileID               BIGINT,        CreateLSN            NUMERIC(25,0), DropLSN              NUMERIC(25,0),
        UniqueID             UNIQUEIDENTIFIER, ReadOnlyLSN       NUMERIC(25,0), ReadWriteLSN         NUMERIC(25,0),
        BackupSizeInBytes    BIGINT,        SourceBlockSize      INT,           FileGroupID          INT,
        LogGroupGUID         UNIQUEIDENTIFIER, DifferentialBaseLSN NUMERIC(25,0), DifferentialBaseGUID UNIQUEIDENTIFIER,
        IsReadOnly           BIT,           IsPresent            BIT,           TDEThumbprint        VARBINARY(32),
        SnapshotURL          NVARCHAR(360)
    );

    -- =================================================================================================================
    -- Main Processing Loop
    -- =================================================================================================================
    DECLARE BackupFileCursor CURSOR FAST_FORWARD FOR
        SELECT FullPath FROM #BackupFiles;

    OPEN BackupFileCursor;
    FETCH NEXT FROM BackupFileCursor INTO @BackupFile;

    WHILE @@FETCH_STATUS = 0
    BEGIN
        SET @DbName = NULL;
        TRUNCATE TABLE #RestoreHeader;
        TRUNCATE TABLE #FileList;

        -- Step 1: Get Backup Header
        BEGIN TRY
            SET @sql = N'RESTORE HEADERONLY FROM DISK = ' + QUOTENAME(@BackupFile, '''');
            INSERT INTO #RestoreHeader EXEC (@sql);

            -- Find the correct backup set within the file based on criteria
            SELECT TOP 1 @DbName = DatabaseName
            FROM #RestoreHeader
            WHERE BackupType = 1 -- Full Backup
              AND BackupStartDate > DATEADD(day, -@BackupInLastXDays, GETDATE())
              AND CompressedBackupSize < CAST(@MaxBackupSizeInGB AS BIGINT) * 1024 * 1024 * 1024
              AND (@DatabaseName IS NULL OR DatabaseName = @DatabaseName)
            ORDER BY BackupStartDate DESC;

        END TRY
        BEGIN CATCH
            SET @ErrorMessage = ERROR_MESSAGE();
            PRINT N'ERROR reading header for file: ' + @BackupFile + N'. Reason: ' + @ErrorMessage;
            INSERT INTO master.dbo.CommandLog (DatabaseName, CommandType, Command, StartTime, EndTime, ErrorNumber, ErrorMessage)
            VALUES (ISNULL(@DatabaseName, 'N/A'), 'RESTORE HEADERONLY FAILED', @sql, GETDATE(), GETDATE(), ERROR_NUMBER(), @ErrorMessage);
            
            FETCH NEXT FROM BackupFileCursor INTO @BackupFile;
            CONTINUE; -- Skip to the next file
        END CATCH;

        IF @DbName IS NULL
        BEGIN
            PRINT 'INFO: No suitable full backup set found in ' + @BackupFile + ' matching the criteria. Skipping.';
            FETCH NEXT FROM BackupFileCursor INTO @BackupFile;
            CONTINUE; -- Skip to the next file
        END;

        -- Step 2: Get File List
        BEGIN TRY
            SET @sql = N'RESTORE FILELISTONLY FROM DISK = ' + QUOTENAME(@BackupFile, '''');
            INSERT INTO #FileList EXEC sp_executesql @sql;
        END TRY
        BEGIN CATCH
            SET @ErrorMessage = ERROR_MESSAGE();
            PRINT N'ERROR reading file list for database ' + QUOTENAME(@DbName) + ' from file: ' + @BackupFile + N'. Reason: ' + @ErrorMessage;
            INSERT INTO master.dbo.CommandLog (DatabaseName, CommandType, Command, StartTime, EndTime, ErrorNumber, ErrorMessage)
            VALUES (@DbName, 'RESTORE FILELISTONLY FAILED', @sql, GETDATE(), GETDATE(), ERROR_NUMBER(), @ErrorMessage);

            FETCH NEXT FROM BackupFileCursor INTO @BackupFile;
            CONTINUE; -- Skip to the next file
        END CATCH;

        -- Step 3: Build the RESTORE command with MOVE options
        DECLARE @MoveClauses NVARCHAR(MAX);
        DECLARE @DataFileCounter INT = 0, @LogFileCounter INT = 0;

        SELECT @MoveClauses = STRING_AGG(
            N'MOVE ' + QUOTENAME(LogicalName, '''') + N' TO ' + 
            QUOTENAME(
                CASE [Type]
                    WHEN 'D' THEN -- Data File
                        (SELECT PathValue FROM #DataPaths WHERE ID = (fl.RowID - 1) % @TotalDataPaths + 1) + @DbName + N'_' + CAST(fl.RowID AS NVARCHAR(10)) + N'.mdf'
                    WHEN 'L' THEN -- Log File
                        (SELECT PathValue FROM #LogPaths WHERE ID = (fl.LogRowID - 1) % @TotalLogPaths + 1) + @DbName + N'_' + CAST(fl.LogRowID AS NVARCHAR(10)) + N'.ldf'
                    -- Add other types like Filestream ('S') if needed
                    ELSE
                        (SELECT PathValue FROM #DataPaths WHERE ID = (fl.RowID - 1) % @TotalDataPaths + 1) + @DbName + N'_' + LogicalName
                END,
            ''''),
            ',' + @crlf + '    ')
        FROM (
            SELECT *,
                ROW_NUMBER() OVER (PARTITION BY [Type] ORDER BY FileID) AS TypeRowID,
                ROW_NUMBER() OVER (PARTITION BY CASE WHEN [Type] = 'D' THEN 1 ELSE 2 END ORDER BY FileID) AS RowID,
                ROW_NUMBER() OVER (PARTITION BY CASE WHEN [Type] = 'L' THEN 1 ELSE 2 END ORDER BY FileID) AS LogRowID
            FROM #FileList
        ) AS fl;
        

        -- Construct the full restore command
        SET @RestoreCommand = N'RESTORE DATABASE ' + QUOTENAME(@DbName) + @crlf
                           + N'FROM DISK = ' + QUOTENAME(@BackupFile, '''') + @crlf
                           + N'WITH ' + @crlf
                           + N'    ' + @MoveClauses + ',' + @crlf
                           + N'    REPLACE,' + @crlf
                           + N'    STATS = 5' + @crlf
                           + CASE WHEN @RunRecovery = 1 THEN N',RECOVERY' ELSE N',NORECOVERY' END
                           + ISNULL(N',BUFFERCOUNT = ' + CAST(@BufferCount AS NVARCHAR(10)), '')
                           + ISNULL(N',MAXTRANSFERSIZE = ' + CAST(@MaxTransferSize AS NVARCHAR(10)), '')
                           + ISNULL(N',BLOCKSIZE = ' + CAST(@BlockSize AS NVARCHAR(10)), '');

        -- Step 4: Execute or Print the command
        PRINT '---------------------------------------------------------------------------------';
        PRINT 'Processing Database: ' + @DbName + ' from file ' + @BackupFile;
        PRINT 'Generated Restore Command:';
        PRINT @RestoreCommand;
        PRINT '---------------------------------------------------------------------------------';
        
        SET @StartTime = GETDATE();
        IF @PrintOnly = 0
        BEGIN
            BEGIN TRY
                -- Pre-Restore: Drop existing database if requested
                IF @DropExistingDatabase = 1 AND DB_ID(@DbName) IS NOT NULL
                BEGIN
                    PRINT 'Dropping existing database: ' + QUOTENAME(@DbName);
                    SET @sql = N'ALTER DATABASE ' + QUOTENAME(@DbName) + N' SET SINGLE_USER WITH ROLLBACK IMMEDIATE;';
                    EXEC sp_executesql @sql;
                    SET @sql = N'DROP DATABASE ' + QUOTENAME(@DbName) + ';';
                    EXEC sp_executesql @sql;
                    PRINT 'Database ' + QUOTENAME(@DbName) + ' dropped successfully.';
                END

                -- Execute Restore
                EXEC sp_executesql @RestoreCommand;

                INSERT INTO master.dbo.CommandLog (DatabaseName, CommandType, Command, StartTime, EndTime, ErrorNumber, ErrorMessage)
                VALUES (@DbName, 'RESTORE DATABASE SUCCEEDED', @RestoreCommand, @StartTime, GETDATE(), 0, 'Success');

                -- Post-Restore: Run CHECKDB
                IF @RunCheckDB = 1
                BEGIN
                    PRINT 'Running DBCC CHECKDB for ' + QUOTENAME(@DbName);
                    SET @sql = N'DBCC CHECKDB (' + QUOTENAME(@DbName) + N') WITH NO_INFOMSGS;';
                    EXEC sp_executesql @sql;
                    PRINT 'DBCC CHECKDB completed successfully for ' + QUOTENAME(@DbName);
                    
                    -- Post-Restore: Delete backup file ONLY if CHECKDB was successful
                    IF @DeleteBackupFile = 1
                    BEGIN
                        PRINT 'Deleting backup file: ' + @BackupFile;
                        EXEC xp_delete_file 0, @BackupFile;
                    END
                END
                ELSE
                BEGIN
                     -- Post-Restore: Delete backup file if CHECKDB was skipped
                    IF @DeleteBackupFile = 1
                    BEGIN
                        PRINT 'Deleting backup file: ' + @BackupFile;
                        EXEC xp_delete_file 0, @BackupFile;
                    END
                END
            END TRY
            BEGIN CATCH
                SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE();
                PRINT 'FATAL ERROR during restore of ' + QUOTENAME(@DbName) + ': ' + @ErrorMessage;
                INSERT INTO master.dbo.CommandLog (DatabaseName, CommandType, Command, StartTime, EndTime, ErrorNumber, ErrorMessage)
                VALUES (@DbName, 'RESTORE DATABASE FAILED', @RestoreCommand, @StartTime, GETDATE(), ERROR_NUMBER(), @ErrorMessage);
                
                -- Decide whether to stop entirely or continue with the next backup file
                -- For now, we continue to allow other restores to proceed.
            END CATCH;
        END

        FETCH NEXT FROM BackupFileCursor INTO @BackupFile;
    END;

    CLOSE BackupFileCursor;
    DEALLOCATE BackupFileCursor;
END;
GO
